---
title: "Raster Pre-Processing"
author: "Oliver Atwood"
output: html_document
date: "`r Sys.Date()`"
---
# Overview
<br>
This r markdown script pre-processes raster data used in the Hotspot Stoplight Project for visualization and cluster analysis. The datasets used in this project are as follows:

* LAND COVER CHANGE PROBABILITY - [Clark Labs](https://env1.arcgis.com/arcgis/rest/services/Land_Cover_Vulnerability_2050/ImageServer0)
* BIODIVERSITY INTACTNESS INDEX - [Impact Observatory](https://gee-community-catalog.org/projects/bii/)
* CLIMATE RISK INDEX - Hotspot Stoplight Team: [Nissim Lebovits](http://nlebovits.github.io/)
* GRIDDED 2020 POPULATION - [Global Human Settlements Layer](https://ghsl.jrc.ec.europa.eu/download.php?ds=bu)
* URBAN LAND COVER PROBABILITY - Hotspot Stoplight Team: [Oliver Atwood](https://www.linkedin.com/in/oliveratwood), using classified data from [Tristan Grupp](https://scholar.google.com/citations?user=yX3Ed8EAAAAJ&hl=en)
<br>
<br>

* Each of these raster datasets are loaded into R and their Coordinate Systems, Resolution, and Extent are standardized. NA values are then removed and each dataset is standardized.
<br>
* Four of these standardized datasets are then combined to produce two 'Interaction Rasters', using the following formulas:
<br>
+ Bio_Loss_Risk = LCC_Probability * BII
<br>
*Bio_Loss_Risk emphasizes areas of high land cover change probability and high biodiversity intactness.*
<br>
+ Climate_Impact_Risk = Climate_Hazards * pop2020
<br>
*Climate_Impact_Risk emphasizes areas of high climate hazard probability and high human population.*
<br>
+ Urban Land Cover Probability is a dataset generated through a random forest model trained on a range of physiographic factors to predict the likelihood of a given cell of a land cover raster to be urban in 2033.
<br>

* Bio_Loss_Risk and Climate_Impact_Risk were both normalized and Bio_Loss_Risk, Climate_Impact_Risk, and Urban Land Cover Probability were exported for clustering analysis.
<br>
* These three datasets were then added together and the resultant raster dataset was normalized to produce a 'Stoplight for Urban Development'.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse=TRUE)
rm(list=ls())
```

```{r, message=FALSE, warning=FALSE, cache=TRUE, results = 'hide', echo=FALSE}
library(sf)
library(raster)
library(dplyr)
library(readr)
library(terra)
library(spdep)
library(rasterVis)
library(lattice)
library(gridExtra)
library(viridis)

# Capture the start time
# start_time <- Sys.time()
```

## Setting Parameters
```{r, message=FALSE, warning=FALSE, cache=TRUE, results = 'hide', echo=FALSE}
coordinate_system <- 4326
# Target resolution in m
# resolution <- 30
resolution <- 60
# Conversion to degrees
resolution <- (resolution/30)/3600

```

## Loading Datasets
```{r, message=FALSE, warning=FALSE, cache=TRUE, echo=FALSE, results = 'hide'}
# Read the Boundary file
# cropbox <- st_read("https://raw.githubusercontent.com/HotspotStoplight/HotspotStoplight/main/CropBoxes/CR_Crop5a.geojson")
cropbox <- st_read("https://raw.githubusercontent.com/HotspotStoplight/HotspotStoplight/main/CropBoxes/CR_Crop5.geojson")
# cropbox <- st_read("https://raw.githubusercontent.com/HotspotStoplight/HotspotStoplight/main/CropBoxes/CR_Crop5b.geojson")
# cropbox <- st_read("https://raw.githubusercontent.com/HotspotStoplight/HotspotStoplight/main/CropBoxes/CR_Crop6.geojson")

# LAND COVER CHANGE PROBABILITY
# URBAN
# url <- "https://github.com/HotspotStoplight/LandCoverChange/raw/main/OUTPUTS/Crop5a_30m/Built.tif"
url <- "https://github.com/HotspotStoplight/LandCoverChange/raw/main/OUTPUTS/crop5_60m/Built.tif"
temp <- tempfile(fileext = ".tif")
download.file(url, temp, method = "auto")
UrbanProbability <- raster(temp)

# CLARK LABS
# url <- "https://github.com/HotspotStoplight/LandCoverChange/raw/main/data/Land_Cover_Change_Probs_Clark.tif"

# OTHER
# url <- "https://github.com/HotspotStoplight/LandCoverChange/raw/main/OUTPUTS/Crop5a_30m/Other.tif"
url <- "https://github.com/HotspotStoplight/LandCoverChange/raw/main/OUTPUTS/crop5_60m/Other.tif"
temp <- tempfile(fileext = ".tif")
download.file(url, temp, method = "auto")
OtherProbability <- raster(temp)

# LCC_Probability <- OtherProbability + UrbanProbability
LCC_Probability <- OtherProbability

# BIODIVERSITY INTACTNESS INDEX
url <- "https://github.com/HotspotStoplight/LandCoverChange/raw/main/data/BiodiversityIntactnessIndex_2020.tif"
temp <- tempfile(fileext = ".tif")
download.file(url, temp, method = "auto")
BII <- raster(temp)

# CLIMATE HAZARDS
url <- "https://github.com/HotspotStoplight/Climate/raw/main/OUTPUT_RASTERS/data-San%20Jose-outputs-flood_prob.tif"
temp <- tempfile(fileext = ".tif")
download.file(url, temp, method = "auto")
Climate_Hazards <- raster(temp)

# add code here to bring in additional risk index rasters

# POPULATION 2020
url <- "https://github.com/HotspotStoplight/LandCoverChange/raw/main/data/Pop_2020_Crop4.tif"
temp <- tempfile(fileext = ".tif")
download.file(url, temp, method = "auto")
pop2020 <- raster(temp)

# add code here for vulnerability-adusted climate risk index raster calculations
# (pop / (HDI * GDP)) * (ClimateHazard1 * ClimateHazard2 * ...)

# List of raster variables
raster_list = list(LCC_Probability, BII, Climate_Hazards, pop2020, UrbanProbability)
```

## Unify Raster Coordinate Systems, Resolutions, and Extents
```{r}
# Specify resolution in meters
resolution <- 90
# Conversion to degrees
resolution <- resolution / (30*3600)

# Extract extent and crs from cropbox
bbox <- st_bbox(cropbox)
extent <- as(extent(bbox), "Extent")
crs <- crs(cropbox)
res <- resolution

# Calculate the number of columns and rows based on the resolution and the extent
nrows <- ceiling((extent@ymax - extent@ymin) / res)
ncols <- ceiling((extent@xmax - extent@xmin) / res)

# Create an empty raster with the specified extent, resolution, and CRS
# Here, we manually specify xmn, xmx, ymn, ymx based on the extent object
r <- raster(nrows=nrows, ncols=ncols, xmn=extent@xmin, xmx=extent@xmax, ymn=extent@ymin, ymx=extent@ymax, crs=crs)

# Define the target characteristics from the raster 'r'
target_crs <- crs(r)
target_extent <- extent(r)
target_resolution <- res(r)

# Initialize an empty list to store the standardized rasters
standardized_rasters <- list()

# Loop through each raster in raster_list to standardize them
for (i in 1:length(raster_list)) {
  # Read the raster
  current_raster <- raster_list[[i]]
  
  # Step 1: Reproject the raster to match the target CRS, using compareCRS for comparison
  if (!compareCRS(crs(current_raster), target_crs)) {
    current_raster <- projectRaster(current_raster, crs = target_crs)
  }
  
  # Step 2: Resample the raster to match the target resolution and extent using bilinear interpolation
  current_raster <- resample(current_raster, r, method = "bilinear")
  
  # Step 3: Crop the raster to ensure it matches the target extent exactly
  current_raster <- crop(current_raster, target_extent)
  
  # Add the standardized raster to the list
  standardized_rasters[[i]] <- current_raster
}

# Naming the lists after projection
raster_names <- c("LCC_Probability", "BII", "Climate_Hazards", "pop2020", "UrbanProbability")
names(standardized_rasters) <- raster_names

# Overwrite raster_list with the standardized rasters
raster_list <- standardized_rasters
```

## Remove all NA values from rasters
```{r, message=FALSE, warning=FALSE, cache=TRUE, echo=FALSE}
# Function to load rasters, replace NA with 0, and return the modified list
process_rasters <- function(raster_list) {
  processed_list <- list() # Initialize an empty list to store processed rasters
  
  for (i in 1:length(raster_list)) {
    # Copy the raster to avoid modifying the original list directly
    raster_data <- raster_list[[i]]
    
    # Replace NA values with 0
    raster_data[is.na(raster_data)] <- 0
    
    # Add the processed raster to the new list
    processed_list[[i]] <- raster_data
  }
  
  # Return the processed list of rasters
  return(processed_list)
}

# Apply the function to raster_list
raster_list <- process_rasters(raster_list)

# Naming the processed list as per the original names
names(raster_list) <- c("LCC_Probability", "BII", "Climate_Hazards", "pop2020", "UrbanProbability")

```

## Define Normalization Functions
MIN-MAX
```{r}
normalize_minmax <- function(raster) {
  # Calculate the minimum and maximum values of the raster
  min_val <- minValue(raster)
  max_val <- maxValue(raster)
  
  # Perform min-max normalization
  # Note: Use overlay or calc function for raster operations
  normalized_raster <- calc(raster, function(x) {
    # Apply the min-max normalization formula
    (x - min_val) / (max_val - min_val)
  })
  
  # Handle any potential division by zero or other anomalies
  normalized_raster[is.na(normalized_raster) | is.infinite(normalized_raster)] <- NA
  
  return(normalized_raster)
}
```
ROBUST
```{r}
normalize_robust <- function(raster) {
  # Calculate the first and third quartiles
  Q1 <- quantile(raster, probs = 0.25, na.rm = TRUE)
  Q3 <- quantile(raster, probs = 0.75, na.rm = TRUE)
  
  # Calculate the interquartile range (IQR)
  IQR <- Q3 - Q1
  
  # Perform robust scaling
  # Note: Use overlay or calc function for raster operations
  normalized_raster <- calc(raster, function(x) {
    # Apply the robust scaling formula
    (x - Q1) / IQR
  })
  
  # Handle any potential division by zero or other anomalies
  normalized_raster[is.infinite(normalized_raster)] <- NA
  
  return(normalized_raster)
}
```
Z-SCORE
```{r}
normalize_zscore <- function(r) {
  # Calculate the mean and standard deviation using cellStats
  mean_val <- cellStats(r, stat = 'mean', na.rm = TRUE)
  std_dev <- cellStats(r, stat = 'sd', na.rm = TRUE)

  cat("Mean value:", mean_val, "Standard Deviation:", std_dev, "\n")

  # Check for NA values or no variation (std_dev == 0)
  if (is.na(mean_val) || is.na(std_dev) || std_dev == 0) {
    cat("No variation, NA, or constant raster values\n")
    return(r)
  }

  # Apply z-score normalization
  normalized_raster <- calc(r, fun = function(x) {(x - mean_val) / std_dev})
  # Replace NaN values with NA if any
  normalized_raster[is.nan(normalized_raster)] <- NA
  return(normalized_raster)
}
```

## Normalize all rasters (z-score)
```{r}
# Run function for raster_list
raster_list <- lapply(raster_list, normalize_zscore)

```

## Plot Rasters for Visual Inspection
```{r, message=FALSE, warning=FALSE, cache=TRUE, echo=FALSE}
plot(raster_list$LCC_Probability)
plot(raster_list$BII)
plot(raster_list$Climate_Hazards)
plot(raster_list$pop2020)
plot(raster_list$UrbanProbability)
```
```{r}
# # Assuming raster_list$BII is your RasterLayer
# bii_raster <- raster_list$BII
# 
# # Extract the values from the raster (excluding NA values)
# bii_values <- getValues(bii_raster)
# 
# # Plot the histogram
# hist(bii_values, main = "Histogram of BII Values", xlab = "BII Value", ylab = "Frequency", col = "blue")

```

## Generate Interaction Rasters
```{r, message=FALSE, warning=FALSE, cache=TRUE, echo=FALSE}
# Multiply LCC_Probability and BII
Bio_Loss_Risk <- raster_list$BII * raster_list$LCC_Probability

# Multiply Climate_Hazards and pop2020
Climate_Impact_Risk <- raster_list$pop2020 * raster_list$Climate_Hazards

# Normalize the interaction rasters
Bio_Loss_Risk_norm <- normalize_minmax(Bio_Loss_Risk)
Climate_Impact_Risk_norm <- normalize_minmax(Climate_Impact_Risk)
UrbanProbability_norm <- normalize_minmax(standardized_rasters$UrbanProbability)

```

## Overlay Rasters to Produce 'Stoplight For Urban Development'
```{r, message=FALSE, warning=FALSE, cache=TRUE, echo=FALSE}
# Weighted Overlay Calculation
Hotspot_Stoplight <- normalize_zscore(UrbanProbability_norm - Bio_Loss_Risk_norm - Climate_Impact_Risk_norm)
```

# Plots
<br>

```{r, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE, echo=FALSE}
# Extract Min and Max Values
min_val <- cellStats(Climate_Impact_Risk_norm, stat = 'min', na.rm = TRUE)
max_val <- cellStats(Climate_Impact_Risk_norm, stat = 'max', na.rm = TRUE)

# Check if min_val and max_val are finite
if (is.finite(min_val) && is.finite(max_val)) {
    # Determine the number of breaks
    num_breaks <- 255

    # Create a sequence of equally spaced breaks
    breaks <- seq(min_val, max_val, length.out = num_breaks)

    # Plot the raster using the defined color ramp
    levelplot(Climate_Impact_Risk_norm, col.regions=magma(num_breaks), at=breaks, main="Climate Impact Risk Index")
} else {
    cat("Raster contains non-finite or NA values only\n")
}

```

```{r, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE, echo=FALSE}
# Extract Min and Max Values
min_val <- cellStats(Bio_Loss_Risk_norm, stat = 'min', na.rm = TRUE)
max_val <- cellStats(Bio_Loss_Risk_norm, stat = 'max', na.rm = TRUE)

# Check if min_val and max_val are finite
if (is.finite(min_val) && is.finite(max_val)) {
    # Determine the number of breaks
    num_breaks <- 255
    # Create a sequence of equally spaced breaks
    breaks <- seq(min_val, max_val, length.out = num_breaks)

    # Plot the raster using the defined color ramp
    levelplot(Bio_Loss_Risk_norm, col.regions=magma(num_breaks), at=breaks, main="Biodiversity Loss Risk Index")
} else {
    cat("Raster contains non-finite or NA values only\n")
}

```

```{r, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE, echo=FALSE}
# Extract Min and Max Values
min_val <- cellStats(UrbanProbability_norm, stat = 'min', na.rm = TRUE)
max_val <- cellStats(UrbanProbability_norm, stat = 'max', na.rm = TRUE)

# Check if min_val and max_val are finite
if (is.finite(min_val) && is.finite(max_val)) {
    # Determine the number of breaks
    num_breaks <- 255

    # Create a sequence of equally spaced breaks
    breaks <- seq(min_val, max_val, length.out = num_breaks)

    # Plot the raster using the defined color ramp
    levelplot(UrbanProbability_norm, col.regions=magma(num_breaks), at=breaks, main="Urban Probability - Random Forest Model")
} else {
    cat("Raster contains non-finite or NA values only\n")
}

```

## Hotspot Stoplight Raster
```{r, fig.width=10, message=FALSE, warning=FALSE, cache=TRUE, echo=FALSE}
# Define the green-yellow-red color ramp
color_ramp <- colorRampPalette(c("red", "yellow", "darkgreen"))

# Extract Min and Max Values
min_val <- cellStats(Hotspot_Stoplight, stat = 'min', na.rm = TRUE)
max_val <- cellStats(Hotspot_Stoplight, stat = 'max', na.rm = TRUE)

# Check if min_val and max_val are finite
if (is.finite(min_val) && is.finite(max_val)) {
    # Determine the number of breaks
    num_breaks <- 255

    # Create a sequence of equally spaced breaks
    breaks <- seq(min_val, max_val, length.out = num_breaks)

    # Plot the raster using the defined color ramp
    plot(Hotspot_Stoplight, col=color_ramp(num_breaks), breaks=breaks, main="Hotspot Stoplight - Integrated Development Risk Index")
} else {
    cat("Raster contains non-finite or NA values only\n")
}

```
## Data Distributions



```{r}
# Extract the values from the raster (excluding NA values)
Climate_Impact_RiskVals <- getValues(Climate_Impact_Risk_norm)
Bio_Loss_RiskVals <- getValues(Bio_Loss_Risk_norm)
UrbanProbabilityVals <- getValues(UrbanProbability_norm)
HotspotStoplightVals <- getValues(Hotspot_Stoplight)

# Plot the histograms
hist(Climate_Impact_RiskVals, main = "Histogram of Climate Impact Risk Values", xlab = "Risk", ylab = "Frequency", col = "blue")
hist(Bio_Loss_RiskVals, main = "Histogram of Biodiversity Loss Risk Values", xlab = "Risk", ylab = "Frequency", col = "blue")
hist(UrbanProbabilityVals, main = "Histogram of Urban Probability Values", xlab = "Probability", ylab = "Frequency", col = "blue")
hist(HotspotStoplightVals, main = "Histogram of Hotspot Stoplight Values", xlab = "Suitability", ylab = "Frequency", col = "blue")

```

## Export Datasets for Further Analysis
```{r, message=FALSE, warning=FALSE, cache=TRUE, echo=FALSE}
# HOTSPOT STOPLIGHT
# Export the raster as a TIFF
# setwd('/Users/oliveratwood/Documents/GitHub/HotspotStoplight/VisualProduction/OUTPUTS/Crop5a_30m')
setwd('/Users/oliveratwood/Documents/GitHub/HotspotStoplight/VisualProduction/OUTPUTS/Crop5_60m')

# Save the final raster
writeRaster(Hotspot_Stoplight, "Hotspot_Stoplight_2024.tif", overwrite=TRUE)

# INTERMEDIATE INDICES
# Export the raster as a TIFF
# setwd('/Users/oliveratwood/Documents/GitHub/HotspotStoplight/VisualProduction/OUTPUTS/Crop5a_30m')
setwd('/Users/oliveratwood/Documents/GitHub/HotspotStoplight/VisualProduction/OUTPUTS/Crop5_60m')

# Save the final rasters
writeRaster(Bio_Loss_Risk_norm, "BioRiskNorm.tif", overwrite=TRUE)
writeRaster(Climate_Impact_Risk_norm, "AnthroRiskNorm.tif", overwrite=TRUE)
writeRaster(UrbanProbability_norm, "UrbanProbability.tif", overwrite=TRUE)
```



```{r, message=FALSE, warning=FALSE, cache=TRUE, echo=FALSE}
# # Capture the end time
# end_time <- Sys.time()
# 
# # Calculate and print the runtime
# runtime <- end_time - start_time
# print(paste("Total runtime:", runtime))
```

